var $jscomp=$jscomp||{};$jscomp.scope={};$jscomp.ASSUME_ES5=!1;$jscomp.ASSUME_NO_NATIVE_MAP=!1;$jscomp.ASSUME_NO_NATIVE_SET=!1;$jscomp.SIMPLE_FROUND_POLYFILL=!1;$jscomp.defineProperty=$jscomp.ASSUME_ES5||"function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value)};$jscomp.getGlobal=function(a){return"undefined"!=typeof window&&window===a?a:"undefined"!=typeof global&&null!=global?global:a};$jscomp.global=$jscomp.getGlobal(this);
$jscomp.polyfill=function(a,b,c,d){if(b){c=$jscomp.global;a=a.split(".");for(d=0;d<a.length-1;d++){var e=a[d];e in c||(c[e]={});c=c[e]}a=a[a.length-1];d=c[a];b=b(d);b!=d&&null!=b&&$jscomp.defineProperty(c,a,{configurable:!0,writable:!0,value:b})}};
$jscomp.polyfill("Array.from",function(a){return a?a:function(a,c,d){c=null!=c?c:function(a){return a};var b=[],f="undefined"!=typeof Symbol&&Symbol.iterator&&a[Symbol.iterator];if("function"==typeof f){a=f.call(a);for(var g=0;!(f=a.next()).done;)b.push(c.call(d,f.value,g++))}else for(f=a.length,g=0;g<f;g++)b.push(c.call(d,a[g],g));return b}},"es6","es3");
$jscomp.checkStringArgs=function(a,b,c){if(null==a)throw new TypeError("The 'this' value for String.prototype."+c+" must not be null or undefined");if(b instanceof RegExp)throw new TypeError("First argument to String.prototype."+c+" must not be a regular expression");return a+""};
$jscomp.polyfill("String.prototype.repeat",function(a){return a?a:function(a){var b=$jscomp.checkStringArgs(this,null,"repeat");if(0>a||1342177279<a)throw new RangeError("Invalid count value");a|=0;for(var d="";a;)if(a&1&&(d+=b),a>>>=1)b+=b;return d}},"es6","es3");
function init(a){var b=new THREE.MeshPhysicalMaterial({color:3750201,metalness:.9,roughness:.4,dithering:!0}),c=new THREE.PlaneBufferGeometry(16E3,16E3);b=new THREE.Mesh(c,b);b.receiveShadow=!0;b.rotation.x+=.9*Math.PI;b.position.set(0,-100,2E3);a.add(b)}var geometry,adjacency,vertices;function calculate(){var a=new THREE.IcosahedronBufferGeometry(1E3,5);geometry=THREE.BufferGeometryUtils.mergeVertices(a,1.2);geometry.scale(9.5E-4,9.5E-4,9.5E-4);populateVertices();populateAdjacency()}
function populateVertices(){var a=new THREE.Vector3,b=geometry.attributes.position;vertices=[];for(var c=0,d=b.count;c<d;c++)a.fromBufferAttribute(b,c),vertices.push(a.clone())}
function populateAdjacency(){function a(a,b,c){for(var d=0;d<a.length;d++){var e=a[d];if(e.a===b&&e.b===c||e.b===b&&e.c===c||e.c===b&&e.a===c)return e}console.error("sheen.error: shouldn't reach here.")}for(var b=geometry.index,c=Array.from({length:vertices.length},function(){return[]}),d=0,e=b.count/3;d<e;d++){var f=3*d,g=b.getX(f+0),h=b.getX(f+1);f=b.getX(f+2);var l=new THREE.Face3(g,h,f);c[g].push(l);c[h].push(l);c[f].push(l)}adjacency=Array.from({length:vertices.length},function(){return[]});
for(b=0;b<c.length;b++)for(d=c[b][0];d.a==b?(adjacency[b].push(d.c),d=a(c[b],b,d.c)):d.b==b?(adjacency[b].push(d.a),d=a(c[b],b,d.a)):(adjacency[b].push(d.b),d=a(c[b],b,d.b)),d!=c[b][0];);}function dispose(){adjacency=geometry=void 0}var camera,interacting=!1,psel=void 0,mouse=new THREE.Vector2,tmpmouse=new THREE.Vector3,mouse3d=new THREE.Vector3,raycaster=new THREE.Raycaster,plane=new THREE.Plane(void 0,-1.8),sphere=new THREE.Sphere(void 0,1);
function init$1(a){camera=a;window.addEventListener("mousemove",onMouseMove);window.addEventListener("mousedown",onMouseDown);window.addEventListener("mouseout",onMouseOut);window.addEventListener("mouseup",onMouseUp);window.addEventListener("touchmove",onTouchMove,{passive:!1});window.addEventListener("touchstart",onTouchDown);window.addEventListener("touchend",onTouchUp)}
function updating(){if(!interacting)return!1;raycaster.setFromCamera(mouse,camera);if(null!=raycaster.ray.intersectSphere(sphere,tmpmouse)&&(mouse3d.copy(tmpmouse),void 0==psel))for(var a=Infinity,b=0;b<vertices.length;b++){var c=mouse3d.distanceTo(vertices[b]);c<a&&(a=c,psel=b)}plane.normal.copy(camera.position).normalize();null!=raycaster.ray.intersectPlane(plane,tmpmouse)&&mouse3d.copy(tmpmouse);return interacting&&psel?!0:!1}
function onMouseMove(a){mouse.x=a.pageX/window.innerWidth*2-1;mouse.y=2*-(a.pageY/window.innerHeight)+1}function onMouseDown(a){0==a.button&&(interacting=!0)}function onMouseUp(a){0==a.button&&(interacting=!1,psel=void 0)}function onMouseOut(){interacting=!1;psel=void 0}function onTouchMove(a){a.preventDefault();mouse.x=a.touches[0].pageX/window.innerWidth*2-1;mouse.y=2*-(a.touches[0].pageY/window.innerHeight)+1}
function onTouchDown(a){interacting=!0;mouse.x=a.touches[0].pageX/window.innerWidth*2-1;mouse.y=2*-(a.touches[0].pageY/window.innerHeight)+1}function onTouchUp(){interacting=!1;psel=void 0}
var through_vert="\nprecision highp float;\n\nattribute vec2 position;\n\nvoid main() {\n\n\tgl_Position = vec4( position, vec2(1.0) );\n\n}\n",constraints_frag="\nprecision highp float;\nprecision highp sampler2D;\n\nuniform vec2 tSize;\nuniform float order;\nuniform sampler2D tPosition0;\nuniform sampler2D tPosition1;\n\nuniform sampler2D tDistancesA;\nuniform sampler2D tDistancesB;\n\nuniform sampler2D tAdjacentsA;\nuniform sampler2D tAdjacentsB;\n\n// get vec2 tex coordinate from index\nvec2 getUV( float id ) { \n\n\tvec2 coords = vec2(\n\t\tfloor( mod( ( id + 0.5 ), tSize.x ) ),\n\t\tfloor( ( id + 0.5 ) / tSize.x )\n\t) + 0.5;\n\n\treturn coords / tSize;\n\n}\n\n// compute offset based on current distance and spring rest distance\nvec3 getDisplacement( vec3 point0, vec3 point1, float restDistance ) {\n\n    float curDistance = distance( point0, point1 );\n\treturn 1.5 * ( curDistance - restDistance ) * ( point1 - point0 ) / curDistance;\n\t\n}\n\n// pack float16 position into float32\nvec3 packPosition( vec2 uv ) {\n\n\treturn ( texture2D( tPosition0, uv ).xyz + texture2D( tPosition1, uv ).xyz ) / 1024.0;\n\n}\n\nvec3 unpackPosition( vec3 pos ) {\n\n\tpos *= 1024.0;\n\n\treturn ( order > 0.0 ) ? floor( pos ) : fract( pos );\n\n}\n\nvoid main() {\n\t\n\tvec3 displacement;\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n\t// indices of adjacent vertices\n\tvec4 adjacentA = texture2D( tAdjacentsA, uv );\n\tvec4 adjacentB = texture2D( tAdjacentsB, uv );\n\n\t// distances of adjacent vertices\n\tvec4 distancesA = texture2D( tDistancesA, uv );\n\tvec4 distancesB = texture2D( tDistancesB, uv );\n\n\t// vertex position\n\tvec3 p0 = packPosition( uv );\n\n\t// adjacent vertices positions\n    vec3 p1 = packPosition( getUV( adjacentA.x ) );\n    vec3 p2 = packPosition( getUV( adjacentA.y ) );\n    vec3 p3 = packPosition( getUV( adjacentA.z ) );\n    vec3 p4 = packPosition( getUV( adjacentA.w ) );\n    vec3 p5 = packPosition( getUV( adjacentB.x ) );\n\tvec3 p6 = packPosition( getUV( adjacentB.y ) );\n\t\n\t// spring-based displacement\n    displacement += getDisplacement( p0, p1, distancesA.x );\n    displacement += getDisplacement( p0, p2, distancesA.y );\n    displacement += getDisplacement( p0, p3, distancesA.z );\n    displacement += getDisplacement( p0, p4, distancesA.w );\n    displacement += getDisplacement( p0, p5, distancesB.x );\n    displacement += ( adjacentB.y > 0.0 ) ? getDisplacement( p0, p6, distancesB.y ) : vec3( 0 );\n\n\tp0 += 0.76 * displacement / ( ( adjacentB.y > 0.0 ) ? 6.0 : 5.0 );\n\n\tgl_FragColor = vec4( unpackPosition( p0 ), 1.0 );\n\n}\n",integrate_frag=
"\nprecision highp float;\nprecision highp sampler2D;\n\nuniform vec2 tSize;\nuniform float order;\nuniform sampler2D tOriginal;\nuniform sampler2D tPrevious0;\nuniform sampler2D tPrevious1;\nuniform sampler2D tPosition0;\nuniform sampler2D tPosition1;\n\n#define dt 0.016\n\nvec3 unpackPosition( vec3 pos ) {\n\n\tpos *= 1024.0;\n\n\treturn ( order > 0.0 ) ? floor( pos ) : fract( pos );\n\n}\n\nvoid main() {\n\n\tfloat dt2 = dt * dt;\n\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n\tvec3 org = texture2D( tOriginal, uv ).xyz;\n\tvec3 prv = ( texture2D( tPrevious0, uv ).xyz + texture2D( tPrevious1, uv ).xyz ) / 1024.0;\n\tvec3 pos = ( texture2D( tPosition0, uv ).xyz + texture2D( tPosition1, uv ).xyz ) / 1024.0;\n\n\tvec3 offset = ( org - pos ) * 20.5 * dt2 * 8.33333;\n\tvec3 disp = ( pos - prv ) * 0.91 + pos;\n\n\tgl_FragColor = vec4( unpackPosition( disp + offset ), 1.0 );\n\n}\n",
mouse_frag="\nprecision highp float;\nprecision highp sampler2D;\n\nuniform float psel;\nuniform vec2 tSize;\nuniform vec3 mouse;\nuniform float order;\nuniform sampler2D tPosition0;\nuniform sampler2D tPosition1;\nuniform sampler2D tOriginal;\n\n// get vec2 tex coordinate from index\nvec2 getUV( float id ) { \n\n\tvec2 coords = vec2(\n\t\tfloor( mod( ( id + 0.5 ), tSize.x ) ),\n\t\tfloor( ( id + 0.5 ) / tSize.x )\n\t) + 0.5;\n\n\treturn coords / tSize;\n\n}\n\n// pack float16 position into float32\nvec3 packPosition( vec2 uv ) {\n\n\treturn ( texture2D( tPosition0, uv ).xyz + texture2D( tPosition1, uv ).xyz ) / 1024.0;\n\n}\n\nvec3 unpackPosition( vec3 pos ) {\n\n\tpos *= 1024.0;\n\n\treturn ( order > 0.0 ) ? floor( pos ) : fract( pos );\n\n}\n\nvoid main() {\n\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n\tvec3 pos = packPosition( uv );\n\tvec3 org = texture2D( tOriginal, uv ).xyz;\n\tvec3 ref = texture2D( tOriginal, getUV( psel ) ).xyz;\n\n\tvec3 diff, proj, offset = mouse - ref;\n\n\tif ( distance( org, ref ) <= 0.1 )  {\n\n\t\tdiff = ref - org;\n\n\t\tproj = dot( diff, offset ) / dot( offset, offset ) * org;\n\n\t\tpos = org + proj + offset;\n\n\t}\n\n\tgl_FragColor = vec4( unpackPosition( pos ), 1.0 );\n\n}\n",
normals_frag="\nprecision highp float;\nprecision highp sampler2D;\n\nuniform vec2 tSize;\n\nuniform sampler2D tPosition0;\nuniform sampler2D tPosition1;\n\nuniform sampler2D tAdjacentsA;\nuniform sampler2D tAdjacentsB;\n\n// get vec2 tex coordinate from index\nvec2 getUV( float id ) { \n\n\tvec2 coords = vec2(\n\t\tfloor( mod( ( id + 0.5 ), tSize.x ) ),\n\t\tfloor( ( id + 0.5 ) / tSize.x )\n\t) + 0.5;\n\n\treturn coords / tSize;\n\n}\n\n// pack float16 position into float32\nvec3 packPosition( vec2 uv ) {\n\n\treturn ( texture2D( tPosition0, uv ).xyz + texture2D( tPosition1, uv ).xyz ) / 1024.0;\n\n}\n\nvoid main () {\n\n    vec3 normal;\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n    // indices of adjacent vertices\n\tvec4 adjacentA = texture2D( tAdjacentsA, uv );\n\tvec4 adjacentB = texture2D( tAdjacentsB, uv );\n\n    // vertex position\n\tvec3 p0 = ( texture2D( tPosition0, uv ).xyz + texture2D( tPosition1, uv ).xyz ) / 1024.0;\n\n\t// adjacent vertices positions\n    vec3 p1 = packPosition( getUV( adjacentA.x ) );\n    vec3 p2 = packPosition( getUV( adjacentA.y ) );\n    vec3 p3 = packPosition( getUV( adjacentA.z ) );\n    vec3 p4 = packPosition( getUV( adjacentA.w ) );\n    vec3 p5 = packPosition( getUV( adjacentB.x ) );\n\tvec3 p6 = packPosition( getUV( adjacentB.y ) );\n    \n    // compute vertex normal contribution\n    normal += cross( p1 - p0, p2 - p0 );\n    normal += cross( p2 - p0, p3 - p0 );\n    normal += cross( p3 - p0, p4 - p0 );\n    normal += cross( p4 - p0, p5 - p0 );\n\n    if ( adjacentB.y > 0.0 ) {\n\n        normal += cross( p5 - p0, p6 - p0 );\n        normal += cross( p6 - p0, p1 - p0 );\n\n    } else {\n\n        normal += cross( p5 - p0, p1 - p0 );\n\n    }\n\n    gl_FragColor = vec4( normalize( normal ), 1.0 );\n}\n",
through_frag="\nprecision highp float;\nprecision highp sampler2D;\n\nuniform vec2 tSize;\nuniform float order;\nuniform sampler2D texture;\n\nvec4 unpackPosition( vec4 pos ) {\n\n\tpos *= 1024.0;\n\n\treturn ( order > 0.0 ) ? floor( pos ) : fract( pos );\n\n}\n\nvoid main() {\n\n\tvec2 uv = gl_FragCoord.xy / tSize.xy;\n\n\tgl_FragColor = unpackPosition( texture2D( texture, uv ) );\n\n}\n",copyShader=new THREE.RawShaderMaterial({uniforms:{order:{},tSize:{type:"v2"},texture:{type:"t"}},vertexShader:through_vert,
fragmentShader:through_frag,fog:!1,lights:!1,depthWrite:!1,depthTest:!1}),integrateShader=copyShader.clone();integrateShader.fragmentShader=integrate_frag;integrateShader.uniforms={dt:{type:"f"},tSize:{type:"v2"},order:{},tOriginal:{type:"t"},tPrevious0:{type:"t"},tPrevious1:{type:"t"},tPosition0:{type:"t"},tPosition1:{type:"t"}};var mouseShader=copyShader.clone();mouseShader.fragmentShader=mouse_frag;
mouseShader.uniforms={psel:{value:null},order:{},tSize:{type:"v2"},mouse:{type:"v3"},tOriginal:{type:"t"},tPosition0:{type:"t"},tPosition1:{type:"t"}};var constraintsShader=copyShader.clone();constraintsShader.fragmentShader=constraints_frag;constraintsShader.uniforms={tSize:{type:"v2"},order:{},tPosition0:{type:"t"},tPosition1:{type:"t"},tAdjacentsA:{type:"t"},tAdjacentsB:{type:"t"},tDistancesA:{type:"t"},tDistancesB:{type:"t"}};var normalsShader=copyShader.clone();normalsShader.fragmentShader=normals_frag;
normalsShader.uniforms={tSize:{type:"v2"},tPosition0:{type:"t"},tPosition1:{type:"t"},tAdjacentsA:{type:"t"},tAdjacentsB:{type:"t"}};var RESOLUTION,renderer,mesh,targetRT,normalsRT,originalRT,previousRT,positionRT,adjacentsRT,distancesRT,steps=40,tSize=new THREE.Vector2,scene=new THREE.Scene,camera$1=new THREE.Camera;
function init$2(a){renderer=a;RESOLUTION=Math.ceil(Math.sqrt(vertices.length));tSize.set(RESOLUTION,RESOLUTION);a=new THREE.BufferGeometry;var b=new Float32Array([-1,-1,3,-1,-1,3]);a.addAttribute("position",new THREE.BufferAttribute(b,2));mesh=new THREE.Mesh(a,copyShader);mesh.frustumCulled=!1;scene.add(mesh);scene.updateMatrixWorld=function(){};adjacentsRT=Array(2);distancesRT=Array(2);positionRT=Array(2);previousRT=Array(2);targetRT=Array(2);normalsRT=createRenderTarget();createPositionTexture();
for(a=0;2>a;a++)createAdjacentsTexture(a),createDistancesTexture(a),positionRT[a]=createRenderTarget(),previousRT[a]=createRenderTarget(),targetRT[a]=createRenderTarget(),copyTexture(originalRT,positionRT[a],!a),copyTexture(originalRT,previousRT[a],!a)}function copyTexture(a,b,c){mesh.material=copyShader;copyShader.uniforms.order.value=c?1:-1;copyShader.uniforms.tSize.value=tSize;copyShader.uniforms.texture.value=a.texture;renderer.setRenderTarget(b);renderer.render(scene,camera$1)}
function createRenderTarget(){return new THREE.WebGLRenderTarget(RESOLUTION,RESOLUTION,{format:THREE.RGBAFormat,type:THREE.HalfFloatType})}function createPositionTexture(){for(var a=new Float32Array(RESOLUTION*RESOLUTION*4),b=vertices.length,c=0;c<b;c++){var d=4*c;a[d+0]=vertices[c].x;a[d+1]=vertices[c].y;a[d+2]=vertices[c].z}b={};b.texture=new THREE.DataTexture(a,RESOLUTION,RESOLUTION,THREE.RGBAFormat,THREE.FloatType);b.texture.needsUpdate=!0;originalRT=b}
function createAdjacentsTexture(a){for(var b=new Float32Array(RESOLUTION*RESOLUTION*4),c=vertices.length,d=0;d<c;d++)for(var e=4*d,f=adjacency[d],g=adjacency[d].length-1,h=0;4>h;h++)b[e+h]=g<4*a+h?-1:f[4*a+h];c={};c.texture=new THREE.DataTexture(b,RESOLUTION,RESOLUTION,THREE.RGBAFormat,THREE.FloatType);c.texture.needsUpdate=!0;adjacentsRT[a]=c}
function createDistancesTexture(a){for(var b=new Float32Array(RESOLUTION*RESOLUTION*4),c=vertices.length,d=vertices,e=0;e<c;e++)for(var f=4*e,g=adjacency[e],h=adjacency[e].length-1,l=d[e],k=0;4>k;k++)b[f+k]=h<4*a+k?-1:l.distanceTo(d[g[4*a+k]]);c={};c.texture=new THREE.DataTexture(b,RESOLUTION,RESOLUTION,THREE.RGBAFormat,THREE.FloatType);c.texture.needsUpdate=!0;distancesRT[a]=c}
function integrate(){mesh.material=integrateShader;integrateShader.uniforms.tSize.value=tSize;integrateShader.uniforms.tOriginal.value=originalRT.texture;integrateShader.uniforms.tPrevious0.value=previousRT[0].texture;integrateShader.uniforms.tPrevious1.value=previousRT[1].texture;integrateShader.uniforms.tPosition0.value=positionRT[0].texture;integrateShader.uniforms.tPosition1.value=positionRT[1].texture;integrateShader.uniforms.order.value=1;renderer.setRenderTarget(targetRT[0]);renderer.render(scene,
camera$1);integrateShader.uniforms.order.value=-1;renderer.setRenderTarget(targetRT[1]);renderer.render(scene,camera$1);var a=previousRT[0];previousRT[0]=positionRT[0];positionRT[0]=targetRT[0];targetRT[0]=a;a=previousRT[1];previousRT[1]=positionRT[1];positionRT[1]=targetRT[1];targetRT[1]=a}
function solveConstraints(){mesh.material=constraintsShader;constraintsShader.uniforms.tSize.value=tSize;constraintsShader.uniforms.tPosition0.value=positionRT[0].texture;constraintsShader.uniforms.tPosition1.value=positionRT[1].texture;constraintsShader.uniforms.tAdjacentsA.value=adjacentsRT[0].texture;constraintsShader.uniforms.tAdjacentsB.value=adjacentsRT[1].texture;constraintsShader.uniforms.tDistancesA.value=distancesRT[0].texture;constraintsShader.uniforms.tDistancesB.value=distancesRT[1].texture;
constraintsShader.uniforms.order.value=1;renderer.setRenderTarget(targetRT[0]);renderer.render(scene,camera$1);constraintsShader.uniforms.order.value=-1;renderer.setRenderTarget(targetRT[1]);renderer.render(scene,camera$1);var a=positionRT[0];positionRT[0]=targetRT[0];targetRT[0]=a;a=positionRT[1];positionRT[1]=targetRT[1];targetRT[1]=a}
function mouseOffset(){mesh.material=mouseShader;mouseShader.uniforms.tSize.value=tSize;mouseShader.uniforms.psel.value=psel;mouseShader.uniforms.mouse.value=mouse3d;mouseShader.uniforms.tOriginal.value=originalRT.texture;mouseShader.uniforms.tPosition0.value=positionRT[0].texture;mouseShader.uniforms.tPosition1.value=positionRT[1].texture;mouseShader.uniforms.order.value=1;renderer.setRenderTarget(targetRT[0]);renderer.render(scene,camera$1);mouseShader.uniforms.order.value=-1;renderer.setRenderTarget(targetRT[1]);
renderer.render(scene,camera$1);var a=positionRT[0];positionRT[0]=targetRT[0];targetRT[0]=a;a=positionRT[1];positionRT[1]=targetRT[1];targetRT[1]=a}
function computeVertexNormals(){mesh.material=normalsShader;normalsShader.uniforms.tSize.value=tSize;normalsShader.uniforms.tPosition0.value=positionRT[0].texture;normalsShader.uniforms.tPosition1.value=positionRT[1].texture;normalsShader.uniforms.tAdjacentsA.value=adjacentsRT[0].texture;normalsShader.uniforms.tAdjacentsB.value=adjacentsRT[1].texture;renderer.setRenderTarget(normalsRT);renderer.render(scene,camera$1)}
function update(){integrate();for(var a=updating(),b=0;b<steps;b++)a&&b<steps-5&&mouseOffset(),solveConstraints();computeVertexNormals()}var RESOLUTION$1,mesh$1;
function init$3(a){RESOLUTION$1=Math.ceil(Math.sqrt(vertices.length));var b=(new THREE.TextureLoader).load("./src/textures/bmpMap.png");b.wrapS=THREE.RepeatWrapping;b.wrapT=THREE.RepeatWrapping;b.repeat.set(2.5,2.5);b=new THREE.MeshPhysicalMaterial({color:16767520,bumpMap:b,bumpScale:.012,metalness:.1,roughness:.6,clearcoat:.8,clearcoatRoughness:.35,sheen:(new THREE.Color(.2,.2,1)).multiplyScalar(1/6),dithering:!0});b.onBeforeCompile=function(a){a.uniforms.tPosition0={value:positionRT[0].texture};
a.uniforms.tPosition1={value:positionRT[1].texture};a.uniforms.tNormal={value:normalsRT.texture};a.vertexShader="precision highp sampler2D;\nuniform sampler2D tPosition0;\nuniform sampler2D tPosition1;\nuniform sampler2D tNormal;\n"+a.vertexShader;a.vertexShader=a.vertexShader.replace("#include <beginnormal_vertex>","vec3 transformed = ( texture2D( tPosition0, position.xy ).xyz + texture2D( tPosition1, position.xy ).xyz ) / 1024.0;\n\t\t\t vec3 objectNormal = normalize( texture2D( tNormal, position.xy ).xyz );\n\t\t\t");
a.vertexShader=a.vertexShader.replace("#include <begin_vertex>","")};var c=new THREE.MeshDepthMaterial;c.onBeforeCompile=function(a){a.uniforms.tPosition0={value:positionRT[0].texture};a.uniforms.tPosition1={value:positionRT[1].texture};a.vertexShader="precision highp sampler2D;\nuniform sampler2D tPosition0;\nuniform sampler2D tPosition1;\n"+a.vertexShader;a.vertexShader=a.vertexShader.replace("#include <begin_vertex>","vec3 transformed = ( texture2D( tPosition0, position.xy ).xyz + texture2D( tPosition1, position.xy ).xyz ) / 1024.0;")};
for(var d=new Float32Array(RESOLUTION$1*RESOLUTION$1*3),e=0,f=RESOLUTION$1*RESOLUTION$1;e<f;e++){var g=3*e;d[g+0]=e%RESOLUTION$1/RESOLUTION$1+.5/RESOLUTION$1;d[g+1]=~~(e/RESOLUTION$1)/RESOLUTION$1+.5/RESOLUTION$1}e=new THREE.BufferGeometry;e.setIndex(geometry.index);e.addAttribute("position",new THREE.BufferAttribute(d,3));e.addAttribute("uv",geometry.attributes.uv);mesh$1=new THREE.Mesh(e,b);mesh$1.customDepthMaterial=c;mesh$1.castShadow=!0;a.add(mesh$1)}var objects,clock=new THREE.Clock;
function init$4(a){var b=new THREE.AmbientLight(16777215,0);b.baseIntensity=.5;var c=new THREE.SpotLight(16616331,0,4E3,Math.PI/6,.2,.11);c.baseIntensity=3.6;c.position.set(.9,.1,-.5).multiplyScalar(400);var d=new THREE.SpotLight(4882408,0,4E3,Math.PI/6,.2,.11);d.baseIntensity=2;d.position.set(-.91,.1,-.5).multiplyScalar(400);var e=new THREE.SpotLight(16777215,0,4E3,Math.PI/5.5,1.4,.08);e.baseIntensity=1.5;e.position.set(0,0,-1).multiplyScalar(4);e.castShadow=!0;e.shadow.radius=3;e.shadow.camera.far=
4E3;e.shadow.mapSize.height=256;e.shadow.mapSize.width=256;var f=new THREE.DirectionalLight(16777215,0);f.baseIntensity=.3;f.position.set(0,1,.5);var g=new THREE.DirectionalLight(16777215,0);g.baseIntensity=1.3;g.position.set(0,1,-.4);a.add(b,c,d,e,f,g);objects=[b,c,d,e,f,g]}function easing(a,b){return 1>(a/=.5)?b/2*a*a*a:b/2*((a-=2)*a*a+2)}
function update$1(){var a=clock.getElapsedTime();if(1<a&&4>a)for(var b=0;b<objects.length;b++)objects[b].intensity=objects[b].baseIntensity*easing((a-1)/3,1)}var renderer$1,camera$2,scene$1,lastOrientation;
function init$5(){renderer$1=new THREE.WebGLRenderer({antialias:!0});renderer$1.setSize(window.innerWidth,window.innerHeight);renderer$1.gammaOutput=!0;renderer$1.physicallyCorrectLights=!0;renderer$1.shadowMap.enabled=!0;renderer$1.shadowMap.type=THREE.PCFShadowMap;document.body.appendChild(renderer$1.domElement);window.addEventListener("resize",onResize);scene$1=new THREE.Scene;scene$1.background=new THREE.Color(1184530);camera$2=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,
.1,4E3);camera$2.position.set(0,-.5,-3.5);camera$2.lookAt(new THREE.Vector3);calculate();init(scene$1);init$4(scene$1);init$3(scene$1);init$1(camera$2,renderer$1.domElement);init$2(renderer$1);dispose();animate()}function animate(){window.orientation!=lastOrientation&&(lastOrientation=window.orientation,onResize());update$1();update();renderer$1.setRenderTarget(null);renderer$1.render(scene$1,camera$2);requestAnimationFrame(animate)}
function onResize(){var a=window.innerWidth,b=window.innerHeight;camera$2.aspect=a/b;camera$2.updateProjectionMatrix();renderer$1.setSize(a,b)}init$5();
